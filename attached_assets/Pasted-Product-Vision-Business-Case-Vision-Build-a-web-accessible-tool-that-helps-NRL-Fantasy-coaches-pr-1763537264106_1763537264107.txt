Product Vision & Business Case

Vision
Build a web-accessible tool that helps NRL Fantasy coaches predict player scores, optimise their squads, and climb overall and head-to-head rankings using data-driven projections rather than gut feel.

Problem
NRL Fantasy is complex: scoring involves many stats (tackles, metres, offloads, etc.), and player prices are driven by break-even maths and form. Most coaches don’t have the time or tooling to:
	•	Parse all the stats and changes round-by-round.
	•	Quantify risk (e.g. low-minute players, injuries, bye rounds).
	•	Identify undervalued players before everyone else.

Solution
Provide an app that:
	•	Ingests real match stats + fantasy metadata.
	•	Re-implements the Fantasy scoring algorithm so it can simulate player scores historically and prospectively.
	•	Uses an ML or statistical model to predict future fantasy scores by player and by team.
	•	Suggests trades, captain choices, and line-ups that maximise projected score subject to salary cap and positional constraints.

Target Users
	•	Primary: NRL Fantasy coaches (casual to serious).
	•	Secondary: Content creators, analysts who want quick projections.

High-Level Goals
	•	Accurately reproduce past Fantasy scores (within a small error margin).
	•	Provide round-ahead projections with useful lift over simple averages (e.g. better than “last 3 game average”).
	•	Offer actionable trade / captaincy suggestions each round.

⸻

2. Scope

In-scope for MVP
	•	Manual user input of their Fantasy squad (copy/paste list of players; later add import helper).
	•	Historical data ingestion for at least the last 3–5 seasons.
	•	Implement scoring engine replicating Fantasy rules (as of chosen season).
	•	Predictive model for next-round player scores per player.
	•	Simple rule-based optimiser:
	•	Suggest top captain / vice-captain.
	•	Suggest 2–3 high value trade-in targets and 2–3 trade-out candidates.
	•	Web UI (or minimal API + docs) that lets a user:
	•	View their squad with projected scores.
	•	See alternative line-ups and trades.

Out of scope (initially)
	•	Live in-match tracking and score updates.
	•	Direct login / scraping of a user’s official Fantasy account.
	•	Full optimisation over an entire season with bye planning, etc. (could be phase 2/3).

⸻

3. Functional Requirements

3.1 Data ingestion
	•	NRL performance stats
	•	Import per-match player stats (runs, tackles, metres, offloads, errors, minutes, etc.) via:
	•	NRL-Data GitHub CSV/JSON, or
	•	nrlR exported data.
	•	Fantasy metadata
	•	Import historical fantasy scores and prices from:
	•	Community site exports (e.g. Footystatistics) and/or
	•	Public JSON where allowed.
	•	Store: price, price_change, breakeven, position(s), ownership%, round, fantasy_points.
	•	Data ingestion jobs:
	•	CLI or script to backfill historical data.
	•	A scheduled job (e.g. Replit cron / external trigger) to import new round data once games are complete.

3.2 Scoring engine
	•	Implement a config-driven scoring engine:
	•	Reads a FantasyScoringRule table containing mapping: stat_key → points / formula.
	•	Applies it to each player’s raw stat line per match.
	•	Support:
	•	Positive stats (tries, assists, tackle breaks, metres, etc.).
	•	Negative stats (missed tackles, errors, penalties, six-again).
	•	Derived stats (metres / 10, kick metres / 30).
	•	Validate:
	•	Back-test vs known fantasy scores per round.
	•	Compute error metrics (MAE/RMSE) and log.

3.3 Prediction engine
	•	For each player + upcoming round:
	•	Generate features using historical data:
	•	Last N games fantasy scores.
	•	Minutes played trend.
	•	Opponent defensive strength.
	•	Home/away, travel, recent injuries or benching (where data available).
	•	Train a model (start simple):
	•	Baseline: rolling weighted average / exponential smoothing.
	•	Phase 2: regression / gradient boosting (e.g. XGBoost / LightGBM or scikit-learn models) using engineered features.
	•	Output: predicted fantasy points with confidence.

3.4 Team & trade optimiser
	•	User inputs:
	•	Current squad (17 scoring players + bench).
	•	Available bank balance and remaining trades (manually).
	•	App returns:
	•	Projected team total for the upcoming round.
	•	Best captain choice (max expected uplift).
	•	Heuristic trade suggestions:
	•	Sort players by predicted points vs price.
	•	Identify underperformers (low predicted value, high price).
	•	Suggest swaps within cap and positional constraints.
	•	Optional extension:
	•	Provide a “What-if” tool:
	•	User simulates trade(s) and sees new projected team total.

3.5 UI / API
	•	For MVP, a simple REST API via FastAPI:
	•	POST /team/project – body: list of players, returns predicted team total + captain suggestion.
	•	GET /players/{player_id}/projection – returns next-round projection, recent history.
	•	GET /players/value-picks – returns list of top value players by position.
	•	Optional web UI:
	•	Minimal single-page app (HTML/JS/front-end) consuming those endpoints.

⸻

4. Non-functional Requirements
	•	Performance: Able to compute projections for an entire player pool (e.g. 500–700 players) within seconds on Replit.
	•	Reliability: Data ingestion scripts handle missing values, new players, and rule changes.
	•	Maintainability:
	•	Scoring rules externalised to config / DB.
	•	Clear module boundaries.
	•	Security:
	•	No storing of user Fantasy login credentials.
	•	All third-party API keys stored in Replit Secrets.
	•	Respect provider ToS (no abusive scraping).

⸻

5. Data Model (Conceptual)

Core entities (tables/classes):
	•	Player
	•	id, name, team, positions, nrl_id, fantasy_id
	•	Match
	•	id, season, round, date, home_team, away_team, venue
	•	PlayerMatchStats
	•	id, player_id, match_id, minutes, runs, run_metres, tackles, missed_tackles, offloads, line_breaks, errors, penalties, kick_metres, tries, try_assists, etc.
	•	FantasyScoringRule
	•	id, season, stat_key (e.g. try, run_metres_per_10), points, formula_type (flat, /10, /30, etc.)
	•	FantasyScore
	•	id, player_id, match_id, round, season, fantasy_points
	•	FantasyPriceHistory
	•	id, player_id, round, season, price, price_change, breakeven, ownership_pct
	•	Projection
	•	player_id, round, season, predicted_points, model_version, confidence

⸻

6. High-Level Architecture (Replit-friendly)

Tech stack (recommended)
	•	Backend: Python + FastAPI
	•	Data / modelling: Pandas, scikit-learn (or similar), optionally xgboost/lightgbm.
	•	Storage:
	•	MVP: SQLite (ships easily with Replit).
	•	Scale-up: Postgres (hosted) if needed.
	•	Scheduling:
	•	Replit “Deployments + cron-like tasks” or external cron to trigger ingestion scripts.

Logical components
	1.	Data Ingestion Service
	•	Scripts/cron jobs to:
	•	Download or scrape NRL stats (from NRL-Data, nrlR exports, or API).
	•	Import Fantasy metadata (from community JSON/CSV).
	•	Writes into Player, Match, PlayerMatchStats, FantasyScore, FantasyPriceHistory.
	2.	Scoring Engine
	•	Uses FantasyScoringRule to convert PlayerMatchStats → FantasyScore.
	•	Includes regression tests vs known fantasy scores for historical rounds.
	3.	Modelling / Projections Service
	•	Training pipeline:
	•	Reads historical FantasyScore + features from PlayerMatchStats & price data.
	•	Trains / updates model.
	•	Inference:
	•	For upcoming round, generates projections for each player.
	•	Stores in Projection.
	4.	API Layer (FastAPI)
	•	Encapsulates projections and optimisation logic.
	•	Endpoints for:
	•	Player projections.
	•	Team total calculations.
	•	Trade suggestions.
	5.	(Optional) Front-end
	•	Simple HTML/JS app hosted in the same Replit project or static hosting.
	•	Calls API to display projections and trade ideas.

⸻

7. Modelling Strategy (Predicting Player Scores)

Phase 1 – Simple & transparent
	•	For each player, compute:
	•	Last N-game average (e.g. 3 and 5 games).
	•	Weighted average giving more weight to recent games.
	•	Adjust for:
	•	Minutes (players coming off bench vs starting).
	•	Opponent defence ranking (e.g. average points conceded to that position).

Phase 2 – ML Regression
	•	Features:
	•	Rolling means of fantasy scores.
	•	Rolling means of core stats (tackles, metres, attacking stats).
	•	Match context: home/away, opponent, round number.
	•	Player role: starter vs bench; position(s).
	•	Model:
	•	Gradient boosting regressor or random forest.
	•	Evaluate with k-fold cross-validation on historical seasons.

Phase 3 – Team optimisation
	•	Once projections are solid:
	•	Implement greedy optimiser:
	•	Rank players by predicted points per $100k.
	•	Propose trades that increase projected team total, respecting salary cap and positions.
	•	Later, you can move to actual integer programming (e.g. pulp or OR-Tools) for optimal squads.

⸻

8. Risk & Compliance Considerations
	•	Rule changes: The Fantasy scoring system changes slightly (e.g., kick metres divisor, negative stat weights). Mitigation: keep scoring rules data-driven per season and expose a config screen.
	•	Data licensing:
	•	Official NRL data and Fantasy data may have usage restrictions.
	•	For a public / commercial product, you’d want:
	•	Either a formal data licence (e.g. Sportradar, NRL Data API).
	•	Or to base your app on clearly permitted community datasets.
	•	Rate limits / blocking:
	•	Any scraping of official or community sites must be lightweight and polite, with caching and respect for robots/ToS.